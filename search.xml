<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[react的一些知识]]></title>
      <url>/2017/07/31/react-basic/</url>
      <content type="html"><![CDATA[<h3 id="1-虚拟DOM"><a href="#1-虚拟DOM" class="headerlink" title="1.虚拟DOM"></a>1.虚拟DOM</h3><p>React的核心机制之一就是虚拟DOM：可以在内存中创建的虚拟DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能</p>
<h3 id="2-props和state的区别"><a href="#2-props和state的区别" class="headerlink" title="2.props和state的区别"></a>2.props和state的区别</h3><p><strong>props</strong> 一般用来父组件向子组件传递数据，而且通常一旦定义就不再改变</p>
<p><strong>state</strong> 一般表示当前组件的一些状态，由组件自身来维护，会随着用户互动而发生变化<br><a id="more"></a></p>
<h3 id="3-diff算法"><a href="#3-diff算法" class="headerlink" title="3.diff算法"></a>3.diff算法</h3><p>react中所有的DOM构建都是通过<strong>虚拟DOM</strong>进行的，当组件的状态或属性发生变化时，react都会重新构建整个DOM树，并将当前整个DOM树和上一次的DOM树进行对比，这里使用到了diff算法。开发者不需再关注当数据发生变化时如何操作DOM，而只要考虑某个状态下界面应该展示的内容。</p>
<blockquote>
<p>diff算法</p>
</blockquote>
<p>react提出了两个假设：<br><strong>1.两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构</strong>。<br><strong>2.对于同一层次的一组子节点，它们可以通过唯一的id进行区分</strong></p>
<p>在这种假设上将两棵DOM树进行逐层比较，如果发现对应的节点是不同的，那就<strong>直接删除旧的节点及其所有子节点、替换成新的节点</strong>；如果是相同的，则<strong>只进行属性的更改</strong>。<br><img src="http://ojx4wlqvg.bkt.clouddn.com/image/blog/dom-diff.png" alt="逐行进行节点比较" width="90%" style="margin-left: 5%"></p>
<p>对于列表节点的比较，因为列表通常具有相同的结构，在对列表进行插入删除替换等操作时，单个节点的整体操作比一个个对比一个个替换的效率高，所以在创建列表的时候会给每一项设置key值。</p>
<p>关于diff算法，这篇博客解释得非常清楚：<a href="http://www.infoq.com/cn/articles/react-dom-diff" target="_blank" rel="external">虚拟DOM Diff算法解析</a></p>
<h3 id="4-组件的生命周期"><a href="#4-组件的生命周期" class="headerlink" title="4.组件的生命周期"></a>4.组件的生命周期</h3><p><img src="http://ojx4wlqvg.bkt.clouddn.com/image/blog/react-lifecycle.png" alt="react生命周期" width="90%" style="margin-left: 5%"></p>
<ul>
<li>componentWillMount()</li>
<li>componentDidMount()</li>
<li>componentWillReceiveProps(nextProps)</li>
<li>shouldComponentUpdate(nextProps, nextState)</li>
<li>componentWillUpdate(nextProps, nextState)</li>
<li>componentDidUpdate(prevProps, prevState)</li>
<li>componentWillUnmount()</li>
</ul>
<h3 id="5-优点"><a href="#5-优点" class="headerlink" title="5.优点"></a>5.优点</h3><ul>
<li><p>1.虚拟DOM性能高<br>它不直接对实际的DOM进行操作，而是引入了虚拟DOM的概念，实现对DOM的局部刷新，提高了性能</p>
</li>
<li><p>2.模块化<br>页面可以分为多个组件的组合，每个组件可以进行独立的开发，便于分工，提高可复用性</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> react </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跨域方法总结]]></title>
      <url>/2017/07/31/cross-origin/</url>
      <content type="html"><![CDATA[<h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h3><p>JSON With Padding，用于ajax中的跨域，详见js面试问题二中的<a href="../../../../2017/07/27/js-question-2/">JSONP</a></p>
<h3 id="2-修改document-domain"><a href="#2-修改document-domain" class="headerlink" title="2.修改document.domain"></a>2.修改document.domain</h3><p>document.domain只能设置成自身或更高一级的父域，且主域必须相同。<br><a id="more"></a></p>
<p>为了能让父域访问子域，可以通过设置document.domain将子域设置成更高一级的父域。</p>
<p>例如父域是www.example.com, 子域是www.test.example.com, 要实现这种跨子域的交互，应该在父域和子域的js文件中都设置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.domain = <span class="string">"www.example.com"</span></div></pre></td></tr></table></figure></p>
<h3 id="3-window-name"><a href="#3-window-name" class="headerlink" title="3.window.name"></a>3.window.name</h3><p>window对象有一个name属性，该属性有个特征：即在<strong>一个窗口(window)</strong> 的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限</p>
<h3 id="4-window-postMessage"><a href="#4-window-postMessage" class="headerlink" title="4.window.postMessage"></a>4.window.postMessage</h3><h4 id="1-API说明"><a href="#1-API说明" class="headerlink" title="(1)API说明"></a>(1)API说明</h4><blockquote>
<p>otherWindow.postMessage(data, origin)<br><strong>otherWindow</strong> 接收消息的窗口对象</p>
</blockquote>
<p><strong>data</strong> 要传递的数据，可以是任意基本类型或者可复制的对象，它会自动被序列化，这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化</p>
<p><strong>origin</strong> 字符串参数，指明目标窗口的源（协议+主机+端口号），这个参数控制消息可以发送到哪些窗口，如果设置为*的话表示没有限制</p>
<blockquote>
<p>MessageEvent</p>
</blockquote>
<p>window.postMessage()方法被调用时，会在所有页面脚本执行完毕之后向目标窗口派发一个 MessageEvent 消息，该消息有4个属性：</p>
<p><strong>data</strong> 从发送窗口传来的消息</p>
<p><strong>source</strong> 发送消息的窗口对象</p>
<p><strong>origin</strong> 发送消息的窗口的源（协议+主机+端口号）</p>
<h4 id="2-代码实例一"><a href="#2-代码实例一" class="headerlink" title="(2)代码实例一"></a>(2)代码实例一</h4><p>A窗口通过postMessage发送消息，B窗口通过监听message事件接收消息</p>
<blockquote>
<p>窗口A：<a href="http://example.a.com" target="_blank" rel="external">http://example.a.com</a> —发送消息</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> popup = <span class="built_in">window</span>.open(<span class="string">'http://example.b.com'</span>);</div><div class="line"></div><div class="line">popup.postMessage(<span class="string">'hello,b'</span>, <span class="string">'http://example.b.com'</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>窗口B：<a href="http://example.b.com" target="_blank" rel="external">http://example.b.com</a> —接收消息</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(event.origin != <span class="string">'http://example.a.com'</span>)&#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(event.data)</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<h4 id="3-代码实例二"><a href="#3-代码实例二" class="headerlink" title="(3)代码实例二"></a>(3)代码实例二</h4><p>A窗口和B窗口相互通信，都发送和接收消息</p>
<blockquote>
<p>窗口A：<a href="http://example.a.com" target="_blank" rel="external">http://example.a.com</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> popup = <span class="built_in">window</span>.open(<span class="string">'http://example.b.com'</span>);</div><div class="line"></div><div class="line">popup.postMessage(<span class="string">'hello,b'</span>, <span class="string">'http://example.b.com'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(event.origin != <span class="string">'http://example.b.com'</span>)&#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(event.data)</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>窗口B：<a href="http://example.b.com" target="_blank" rel="external">http://example.b.com</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(event.origin != <span class="string">'http://example.a.com'</span>)&#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(event.data)</div><div class="line">    event.source.postMessage(<span class="string">'thank you, a'</span>, event.origin);</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深复制和浅复制]]></title>
      <url>/2017/07/28/deep-shadow-copy/</url>
      <content type="html"><![CDATA[<h3 id="1-浅复制"><a href="#1-浅复制" class="headerlink" title="1.浅复制"></a>1.浅复制</h3><blockquote>
<p>浅复制的含义</p>
</blockquote>
<p>浅复制只复制一层对象的属性，并不会进行递归复制；针对引用类型，只复制了引用地址，不会复制引用的对象，即obj.arr和shadowObj.arr指向的是同一个对象。<br><a id="more"></a></p>
<blockquote>
<p>浅复制的实现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shadowCopy</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> temp = &#123;&#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj)&#123;</div><div class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(prop))&#123;</div><div class="line">            temp[prop] = obj[prop]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> temp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="attr">age</span>: <span class="number">10</span>,</div><div class="line">    <span class="attr">colors</span>: [<span class="string">'pink'</span>, <span class="string">'green'</span>]</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> shadowObj = shadowCopy(obj)</div><div class="line"><span class="comment">//此时obj.colors === shadowObj.colors</span></div></pre></td></tr></table></figure>
<h3 id="2-深复制"><a href="#2-深复制" class="headerlink" title="2.深复制"></a>2.深复制</h3><blockquote>
<p>深复制的含义</p>
</blockquote>
<p>深复制它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。</p>
<blockquote>
<p>深复制的实现</p>
</blockquote>
<p>（1）方法一<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="attr">age</span>: <span class="number">10</span>,</div><div class="line">    <span class="attr">colors</span>: [<span class="string">'pink'</span>, <span class="string">'green'</span>]</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> deepObj = deepCopy(obj)</div><div class="line"><span class="comment">//此时obj.colors != deepObj.colors</span></div></pre></td></tr></table></figure></p>
<p>（2）更完善的方法二<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> newObj = obj.constructor == <span class="string">'Array'</span> ? [] : &#123;&#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj != <span class="string">'object'</span>)&#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.JSON)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj)&#123;</div><div class="line">        newObj[prop] = <span class="keyword">typeof</span> obj[prop] === <span class="string">'object'</span> ? deepCopy(obj[prop]) : obj[prop]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newObj</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript面试问题（二）]]></title>
      <url>/2017/07/27/js-question-2/</url>
      <content type="html"><![CDATA[<h3 id="1-ajax原理"><a href="#1-ajax原理" class="headerlink" title="1.ajax原理"></a>1.ajax原理</h3><blockquote>
<p>代码实现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ajax</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.method = obj.method || <span class="string">'get'</span></div><div class="line">    <span class="keyword">this</span>.url = obj.url || <span class="string">''</span></div><div class="line">    <span class="keyword">this</span>.async = obj.async || <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.data = obj.data || <span class="string">''</span></div><div class="line">    <span class="keyword">this</span>.callback = obj.callback || <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Ajax.prototype.send = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</div><div class="line">    xhr.onreadystatechange = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">        <span class="keyword">if</span>(xhr.readystate == <span class="number">4</span>)&#123;</div><div class="line">            callback(xhr.responseText)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(method == <span class="string">'get'</span>)&#123;</div><div class="line">        xhr.open(<span class="string">'GET'</span>, url, <span class="keyword">async</span>)</div><div class="line">        xhr.send(<span class="literal">null</span>)</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(method == <span class="string">'post'</span>)&#123;</div><div class="line">        xhr.open(<span class="string">'POST'</span>, url, <span class="keyword">async</span>)</div><div class="line">        xhr.setRequestHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/x-www-form-urlencoded'</span>)</div><div class="line">        xhr.send(data)</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'无法识别方法'</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ajax = <span class="keyword">new</span> Ajax(&#123;</div><div class="line">    <span class="attr">method</span>: <span class="string">'post'</span>,</div><div class="line">    <span class="attr">url</span>: <span class="string">'http://localhost:3000'</span>,</div><div class="line">    <span class="attr">async</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">data</span>: <span class="built_in">JSON</span>.stringify(data),</div><div class="line">    <span class="attr">callback</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(res)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">ajax.send()</div></pre></td></tr></table></figure>
<blockquote>
<p>XMLHttpRequest对象的属性</p>
</blockquote>
<ul>
<li><strong>onreadystatechange</strong> 每次readystate改变触发的事件处理程序</li>
<li><strong>readyState</strong> 对象状态值<br>-0表示未初始化，还没调用open方法<br>-1表示初始化，已调用open未调用send方法<br>-2表示发送数据，已调用send，但当前状态和http头未知<br>-3表示接收数据，已接收部分数据<br>-4表示完成，数据接收完毕</li>
<li><strong>status</strong> 从服务器返回的状态码，如200，404</li>
<li><strong>statusText</strong> 伴随status的描述文字，如OK</li>
<li><strong>responseText</strong> 从服务器返回的数据的字符串形式</li>
</ul>
<blockquote>
<p>优点</p>
</blockquote>
<p>-异步获取数据，不打断用户的操作<br>-前后端分离</p>
<h3 id="2-JSONP的工作原理"><a href="#2-JSONP的工作原理" class="headerlink" title="2.JSONP的工作原理"></a>2.JSONP的工作原理</h3><blockquote>
<p>出现原因</p>
</blockquote>
<p>浏览器发送ajax请求的时候只能请求同源地址上的数据，不能跨域请求；但是html页面上的script标签可以请求跨域的javascript文件。注意JSONP只能用于get操作。</p>
<blockquote>
<p>工作原理</p>
</blockquote>
<p>1.创建一个方法来处理从API处返回的数据<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallbackFunction</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.在页面上加一个script标签，来加载API，同时在url后面添加callback参数<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://other.com/api.json?callback=myCallbackFunction"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>3.服务器上对应的API会返回数据，但不是单纯的JSON，而是包裹着回调函数的JSON</p>
<p>4.script标签拿到返回的数据后会立即执行，即调用myCallbackFunction，在控制台打印出data</p>
<h3 id="3-解释hoisting（提升）"><a href="#3-解释hoisting（提升）" class="headerlink" title="3.解释hoisting（提升）"></a>3.解释hoisting（提升）</h3><p>提升是指js中的声明会被解析器提升到所在作用域的顶部。</p>
<blockquote>
<p>变量声明提升</p>
</blockquote>
<p>var temp = 1;这句语句会被拆成var temp; （被提升到当前作用于的顶部）以及temp = 1;（初始化保留在原位置）。</p>
<blockquote>
<p>函数声明提升</p>
</blockquote>
<p>变量只是提升声明、不提升初始化，但是函数会将声明和定义一起提升到作用域顶部。<strong>注意：</strong> 函数提升优先级比变量提升高，不会被变量声明覆盖，但会被变量赋值覆盖</p>
<p>下面两段代码，后者是前者提升之后的实际顺序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">containingFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hoisted = <span class="string">"I'm the variable"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hoisted</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"I'm the function"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hoisted(); <span class="comment">// results in a TypeError</span></div><div class="line">&#125;</div><div class="line">containingFunction()</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">containingFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hoisted</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"I'm the function"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> hoisted;</div><div class="line">    hoisted = <span class="string">"I'm the variable"</span>;</div><div class="line">    <span class="keyword">return</span> hoisted();</div><div class="line">&#125;</div><div class="line">containingFunction()</div></pre></td></tr></table></figure>
<h3 id="4-同源策略"><a href="#4-同源策略" class="headerlink" title="4.同源策略"></a>4.同源策略</h3><p>同源策略限制了一个域上的脚本只可以与同源的资源交互，同源策略可以有效防止来自其他源的恶意攻击。<br>同源是指<strong>协议(http vs https)、域名、端口号都相等</strong>，只要任一个值不同，就认为是不同源。</p>
<h3 id="5-”use-strict”的优缺点是什么"><a href="#5-”use-strict”的优缺点是什么" class="headerlink" title="5.”use strict”的优缺点是什么"></a>5.”use strict”的优缺点是什么</h3><blockquote>
<p>定义</p>
</blockquote>
<p>把”use strict”放在代码或方法的顶部，js将会以严格模式来执行，严格模式会抛出更多的错误以及禁止一些特性，目的是为了让你的代码更健壮、更精确、可读性更好。</p>
<blockquote>
<p>优点</p>
</blockquote>
<p>-捕获常见的代码错误，抛出异常；<br>-它会防止一些不安全的行为发生，或者当发生的时候抛出异常；<br>-它会禁用一些令人困惑或考虑不周的特性。</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>-当混用严格模式和正常(normal)模式的时候会有一些问题；<br>-严格模式的限制很多，有些开发人员希望使用语言的所有特性</p>
<h3 id="6-可变对象和不可变对象的区别"><a href="#6-可变对象和不可变对象的区别" class="headerlink" title="6.可变对象和不可变对象的区别"></a>6.可变对象和不可变对象的区别</h3><blockquote>
<p>不可变对象</p>
</blockquote>
<p>不可变是指一旦初始化一个对象，你就不能再修改它的property了。例如字符串数值，它永远创造一个新的实例，然后存到一个变量里，字符串上的任何操作都不会影响它的初始值。<br>var str = “abc”; //当你创建abc字符串的时候，分配了内存给abc，这个内存是不会变的，直到被垃圾回收。</p>
<p>-优点：防止对对象的意外修改；内存分配固定，不需要扩充<br>-缺点：性能比较差，总是要创建新的实例</p>
<blockquote>
<p>可变对象</p>
</blockquote>
<p>比如数组。<br>var num = [1,2,3]; num[0] = “a”; console.log(num); //[“a”,2,3]</p>
<h3 id="7-javascript中的事件循环、调用栈、任务队列"><a href="#7-javascript中的事件循环、调用栈、任务队列" class="headerlink" title="7.javascript中的事件循环、调用栈、任务队列"></a>7.javascript中的事件循环、调用栈、任务队列</h3><p><img src="http://ojx4wlqvg.bkt.clouddn.com/image/blog/eventloop.png" width="200" height="200" alt="堆栈队列示意图"><br>javascript是一种单线程语言</p>
<blockquote>
<p>堆</p>
</blockquote>
<p>对象被分配在堆(heap)中，栈内存中存放指向堆内存对象的地址</p>
<blockquote>
<p>栈</p>
</blockquote>
<p>javascript中的基本类型的值被存储在栈空间，它们占有固定大小的空间<br>函数调用形成了一个栈（stack），当调用一个函数的时候，会在栈中创建一个帧(橙色)，包括了函数的参数和局部变量，当执行函数内return语句后，函数会从栈中出栈</p>
<blockquote>
<p>消息队列</p>
</blockquote>
<p>js运行的时候包含了一个待处理的消息队列(queue)，每一个消息都和一个函数关联。当栈为空的时候，就从消息队列中取出一个消息进行处理。这个处理包含了调用与之相关的函数，在栈中创建该函数的帧。当栈再次为空的时候，表示该消息处理结束。</p>
<p>一个消息执行完成之后其他消息才能执行；当有一个事件发生、并且这个事件上绑定了事件监听器，就在向消息队列中添加一个消息。<br>如果用setTimeout来执行函数，那么函数会在设定时间（即setTimeout的第二个参数）后加入消息队列，但是并不一定在设定时间后立即执行，因为要等待消息队列里的之前的消息执行完毕。所以第二个参数只是至少要等待的时间。</p>
<h3 id="8-let和var的区别"><a href="#8-let和var的区别" class="headerlink" title="8.let和var的区别"></a>8.let和var的区别</h3><ul>
<li><p>let是块级作用域，var是函数作用域</p>
</li>
<li><p>重复声明并赋值一个变量时，let报错，var不会报错</p>
</li>
<li><p>let不会进行变量提升，var会提升</p>
</li>
<li><p>let和const的暂时性死区：进入它的作用域，它不能被访问直到执行到达声明</p>
</li>
</ul>
<h3 id="9-如何将伪数组转化为标准数组"><a href="#9-如何将伪数组转化为标准数组" class="headerlink" title="9.如何将伪数组转化为标准数组"></a>9.如何将伪数组转化为标准数组</h3><blockquote>
<p>定义</p>
</blockquote>
<p>无法直接调用数组方法 || length属性没有什么特殊含义，但是可以用遍历数组的方法遍历它。典型的伪数组有函数的arguments参数，DOM中的NodeList对象。</p>
<blockquote>
<p>转化方法</p>
</blockquote>
<p>Array.prototype.slice.call(fakeArray)</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript面试问题（一）]]></title>
      <url>/2017/07/26/js-question-1/</url>
      <content type="html"><![CDATA[<h3 id="1-解释一下事件委托"><a href="#1-解释一下事件委托" class="headerlink" title="1.解释一下事件委托"></a>1.解释一下事件委托</h3><p><strong>事件委托</strong>是指利用事件冒泡，将子元素的事件处理程序绑定到祖先元素上，当任意子元素发生事件时，这个事件处理程序就会被触发。一般通过e.target.name/e.target.id等来判断发生事件的具体是哪个子元素。<br><a id="more"></a></p>
<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li><p>减少添加事件监听所需引用的DOM，减少事件监听的内存占用，提高性能</p>
</li>
<li><p>更容易解绑</p>
</li>
<li><p>对于动态添加的子元素，不必再额外绑定事件</p>
</li>
</ul>
<p><strong>事件</strong>是指浏览器窗口发生的一些特定的交互瞬间</p>
<p><strong>事件流</strong>是指从页面上接收事件的顺序</p>
<blockquote>
<p>事件流的阶段</p>
</blockquote>
<p><strong>捕获阶段：</strong> 事件最开始由最不具体的节点接收，最后传播到最具体的节点；</p>
<p><strong>处于目标阶段</strong></p>
<p><strong>冒泡阶段：</strong> 事件最开始由最具体（文档嵌套层次最深）的节点接收，然后逐级向上传播到较不具体的节点。</p>
<h3 id="2-javascript中this的工作原理"><a href="#2-javascript中this的工作原理" class="headerlink" title="2.javascript中this的工作原理"></a>2.javascript中this的工作原理</h3><p>this是在运行时基于函数的执行环境绑定的，所以每次调用函数时this值可能是不一样的。</p>
<p>-全局环境中调用函数，this指向window<br>-当函数作为某个对象的方法调用的时候，this指向该对象<br>-当this出现在构造函数中，this指向new出来的新对象<br>-func.call(o,arg1,arg2,arg3)中this指向o<br>-func.apply(o,[arg1,arg2,arg3])中this指向o<br>-let f = func.bind(o) 绑定之后，f内部的this始终指向o<br>-事件处理程序中，this永远等于currentTarget<br>-在html属性onclick中，this指向当前的DOM元素</p>
<h3 id="3-AMD和CommonJS"><a href="#3-AMD和CommonJS" class="headerlink" title="3.AMD和CommonJS"></a>3.AMD和CommonJS</h3><p>AMD(asynchronous module definition)和CommonJS</p>
<blockquote>
<p>相同点</p>
</blockquote>
<p>AMD和CommonJS是两种通用的模块规范API。模块就是一组实现特定功能的方法。</p>
<blockquote>
<p>区别</p>
</blockquote>
<p><strong>CommonJS</strong>使用同步加载，适合服务器端，使用exports暴露模块方法，使用require([module])加载模块，实现这个规范的有nodejs</p>
<p><strong>AMD异步模块定义</strong>，它使用异步方式加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都封装在回调函数中，当模块加载完成之后执行回调函数；适合浏览器端；require([module],callback).实现这个规范的有requirejs.</p>
<h3 id="4-null-undefined-和-undeclared变量之间的区别"><a href="#4-null-undefined-和-undeclared变量之间的区别" class="headerlink" title="4.null, undefined 和 undeclared变量之间的区别"></a>4.null, undefined 和 undeclared变量之间的区别</h3><blockquote>
<p>declared和undeclared<br>没有用var来声明的变量被称为是undeclared。当执行赋值代码后，它会成为一个全局变量。在严格模式下，这个变量将不存在。两者的区别有:</p>
</blockquote>
<p>1.已声明的变量被限制在执行上下文中，而未声明的变量永远是全局变量；<br>2.已声明的变量会在任何代码执行前被创建出来（创建时值为undefined），未声明的变量不会存在直到运行到赋值代码处；</p>
<blockquote>
<p>undefined</p>
</blockquote>
<p>undefined是一种基本类型，当变量不存在或者已经声明但是还未被赋值的时候，变量的类型是undefined<br>判断方法：typeof variable == ‘undefined’</p>
<blockquote>
<p>null</p>
</blockquote>
<p>变量被赋予的值是空值<br>判断方法：variable == null（typeof的结果是object）</p>
<h3 id="5-什么是闭包，以及你怎么使用闭包的"><a href="#5-什么是闭包，以及你怎么使用闭包的" class="headerlink" title="5.什么是闭包，以及你怎么使用闭包的"></a>5.什么是闭包，以及你怎么使用闭包的</h3><p>闭包是指<strong>有权访问另一个函数内部变量的函数</strong>。闭包由两个部分组成：函数和创建该函数的环境，环境由创建该闭包时作用域中存在的任何局部变量组成。</p>
<blockquote>
<p>优点</p>
</blockquote>
<p>-闭包允许将函数与其所操作的某些数据关联起来；<br>-闭包可以模拟私有变量和私有方法，提供一个公共函数来访问；<br>-有利于限制对代码的访问，提供了管理全局命名空间的能力；<br>-读取函数的内部变量，使这些变量的值始终保存在内存中。</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>变量常驻内存，会增大内存使用量</p>
<h3 id="6-native-objects和host-objects的区别"><a href="#6-native-objects和host-objects的区别" class="headerlink" title="6.native objects和host objects的区别"></a>6.native objects和host objects的区别</h3><blockquote>
<p>native objects本地对象</p>
</blockquote>
<p>是指<strong>由ECMAScript实现的对象</strong>，它的语义是由ECMAScript规范定义的；本地对象可以是内置的，也可以是ECMAScript程序执行时构建的<br>例如：Object/String/Array/Number/Math等及它们的方法</p>
<blockquote>
<p>host objects主机对象</p>
</blockquote>
<p>完成ECMAScript执行的<strong>宿主环境提供的对象</strong>，不同环境下的主机对象是不一样的<br>例如：浏览器下的window/document/XMLHttpRequest/setTimeout/getElementById,nodejs下的NodeList对象</p>
<h3 id="7-new操作符执行的操作"><a href="#7-new操作符执行的操作" class="headerlink" title="7.new操作符执行的操作"></a>7.new操作符执行的操作</h3><p>new 用来创建一个用户自定义对象类型的实例或者具有构造函数的内置对象类型的实例，它经过如下步骤：</p>
<ul>
<li>1.创建一个新的对象x</li>
<li>2.将对象的__proto__指向构造函数的原型</li>
<li>3.执行构造函数，同时this指向新对象</li>
<li>4.若构造函数有返回一个对象，那么new的结果就是这个对象；（一般构造函数不会返回值）否则new的结果就是1中创建的对象x</li>
</ul>
<h3 id="8-call和apply的区别"><a href="#8-call和apply的区别" class="headerlink" title="8.call和apply的区别"></a>8.call和apply的区别</h3><p>call和apply都可以指定函数执行时的this值</p>
<p>call的第一个参数是指定的this值，其他参数是列出的函数参数</p>
<p>apply的第一个参数是指定的this值，第二个参数是函数参数组成的数组</p>
<h3 id="9-串联两个数组的方法"><a href="#9-串联两个数组的方法" class="headerlink" title="9.串联两个数组的方法"></a>9.串联两个数组的方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = arr1.concat(arr2)</div><div class="line"><span class="keyword">let</span> arr = [...arr1, ...arr2]</div><div class="line"><span class="built_in">Array</span>.prototype.unshift.apply(arr2, arr1)</div><div class="line"><span class="comment">//concat方法、扩展语法、unshift方法</span></div></pre></td></tr></table></figure>
<h3 id="10-特征检测-特征推断-和使用用户代理字符串的区别"><a href="#10-特征检测-特征推断-和使用用户代理字符串的区别" class="headerlink" title="10.特征检测, 特征推断, 和使用用户代理字符串的区别"></a>10.特征检测, 特征推断, 和使用用户代理字符串的区别</h3><blockquote>
<p>特征检测feature detection</p>
</blockquote>
<p>检测某个特性是否存在<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</div><div class="line">    <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>特征推断feature inference</p>
</blockquote>
<p>作出某种假设，因为特征A存在，所以特征B也存在<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.getElementsByTagName) &#123;</div><div class="line">    element = <span class="built_in">document</span>.getElementById(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>使用用户代理字符串</p>
</blockquote>
<p>用户代理字符串包含了浏览器的相关信息，每次HTTP请求中，响应头中都会包含用户代理字符串，并且可以通过navigator.userAgent来访问<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (navigator.userAgent.indexOf(<span class="string">"MSIE 7"</span>) &gt; <span class="number">-1</span>)&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css面试问题（三）]]></title>
      <url>/2017/07/26/css-question-3/</url>
      <content type="html"><![CDATA[<h3 id="1-link和-import的区别"><a href="#1-link和-import的区别" class="headerlink" title="1.link和@import的区别"></a>1.link和@import的区别</h3><p>link属于HTML标签，而@import完全是CSS提供的一种方式。 link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了。</p>
<ul>
<li><p>加载顺序的区别<br>当一个页面被加载的时候，link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载</p>
</li>
<li><p>兼容性的区别<br>由于@import 是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题</p>
<a id="more"></a>
</li>
</ul>
<h3 id="2-CSS-Hack"><a href="#2-CSS-Hack" class="headerlink" title="2.CSS Hack"></a>2.CSS Hack</h3><p>针对不同浏览器编写的CSS代码。</p>
<blockquote>
<p>条件注释法</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--[if IE]&gt;</span></div><div class="line">这段文字只在IE浏览器显示</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>类内属性前缀法</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*background:blue;</div><div class="line">_color:#ff0; / For IE6 and earlier */</div></pre></td></tr></table></figure>
<blockquote>
<p>选择器前缀法</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* <span class="selector-tag">html</span> <span class="selector-class">.test</span>&#123;<span class="attribute">color</span>:<span class="number">#090</span>;&#125; <span class="comment">/* For IE6 and earlier */</span></div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css面试问题（二）]]></title>
      <url>/2017/07/26/css-question-2/</url>
      <content type="html"><![CDATA[<h3 id="1-可伸缩矢量图形SVG"><a href="#1-可伸缩矢量图形SVG" class="headerlink" title="1.可伸缩矢量图形SVG"></a>1.可伸缩矢量图形SVG</h3><p>SVG(Scalable Vector Graphics)可伸缩矢量图形，是一种用来描述二维矢量图形的XML语言；在放大或缩小图像尺寸的时候，画质不会受损。flash是基于二进制的。</p>
<p>SVG文件以.svg作为后缀，HTML页面引入svg，通过object或iframe或embed。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;svg version=&quot;1.1&quot;</div><div class="line">     baseProfile=&quot;full&quot;</div><div class="line">     width=&quot;300&quot; height=&quot;200&quot;</div><div class="line">     xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</div><div class="line">  &lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;red&quot; /&gt;</div><div class="line">  &lt;circle cx=&quot;150&quot; cy=&quot;100&quot; r=&quot;80&quot; fill=&quot;green&quot; /&gt;</div><div class="line">  &lt;text x=&quot;150&quot; y=&quot;125&quot; font-size=&quot;60&quot; text-anchor=&quot;middle&quot; fill=&quot;white&quot;&gt;SVG&lt;/text&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">"image.svg"</span> <span class="attr">type</span>=<span class="string">"image/svg+xml"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"image.svg"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="2-使用CSS预处理器的优缺点"><a href="#2-使用CSS预处理器的优缺点" class="headerlink" title="2.使用CSS预处理器的优缺点"></a>2.使用CSS预处理器的优缺点</h3><p>预处理器定义了一种新的编程语言，最终生成的目标文件是CSS文件。常见的预处理语言有Sass/Less/Stylus/Swithch CSS/CSS Cacheer/DT CSS</p>
<blockquote>
<p>优点</p>
</blockquote>
<p>-编码时无需考虑浏览器兼容性<br>-修改一处代码可以达到全局变化<br>-可以使用嵌套、变量、混合、函数等方便的功能</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>-依靠预处理器进行任何更新或修改，调试比较困难</p>
<h3 id="3-css选择器的优先级"><a href="#3-css选择器的优先级" class="headerlink" title="3.css选择器的优先级"></a>3.css选择器的优先级</h3><blockquote>
<p>样式文件的优先级（由低到高）</p>
</blockquote>
<p>-浏览器默认样式<br>-开发人员编写的样式（外部&lt;嵌入&lt;内嵌）<br>-!important注明的样式<br><strong>就近原则</strong>如果两条规则有相同的源和权重，那么后者覆盖前者</p>
<blockquote>
<p>计算选择器权重的规则</p>
</blockquote>
<p>+1 元素、伪元素（如::before）<br>+10 属性(如[type=”text”])、类、伪类(如:link或:hover，否定伪类不算)<br>+100 id<br>+1000 内嵌样式</p>
<h3 id="4-如何筛选匹配一个CSS规则的元素"><a href="#4-如何筛选匹配一个CSS规则的元素" class="headerlink" title="4.如何筛选匹配一个CSS规则的元素"></a>4.如何筛选匹配一个CSS规则的元素</h3><p>浏览器解析选择器的时候，是<strong>从右向左</strong>解析的。最右侧的选择器叫key，从key开始先产生一个元素集合，然后判断集合中的元素是否满足向左一项的选择器，如果不满足，就把元素从集合中删除；一直检查完最左侧的选择器，此时还在元素集合中的元素就是满足CSS规则的元素。</p>
<p>为什么从右向左匹配：因为效率高，查找元素的父元素或兄弟元素比查找一个元素的子元素要简单</p>
<h3 id="5-描述伪元素以及它们的作用"><a href="#5-描述伪元素以及它们的作用" class="headerlink" title="5.描述伪元素以及它们的作用"></a>5.描述伪元素以及它们的作用</h3><blockquote>
<p>定义</p>
</blockquote>
<p>伪元素添加到选择器，为元素的某些部分设置样式。</p>
<blockquote>
<p>常用伪元素</p>
</blockquote>
<p><strong>::before</strong>    创建了一个伪元素作为匹配元素的第一个子元素，通常通过设置content属性来添加修饰的内容；默认是inline元素<br><strong>::after</strong>        与before类似，但它创建的元素作为匹配元素的最后一个子元素；<br><strong>::first-letter</strong>    作用于一个块的第一行的第一个字母；<br><strong>::first-line</strong>    作用于一个元素的第一行 (text-transform/margin-left/text-indent不起作用)；<br><strong>::selection</strong>        作用于一个文档中被用户强调的部分（如鼠标选中）；</p>
<h3 id="6-解释盒模型"><a href="#6-解释盒模型" class="headerlink" title="6.解释盒模型"></a>6.解释盒模型</h3><blockquote>
<p>盒模型</p>
</blockquote>
<p>所有的HTML元素都可以看做盒子，盒模型是指包围在一个HTML元素外围的盒子，包括实际内容content+padding+border+margin。</p>
<blockquote>
<p>box-sizing属性</p>
</blockquote>
<p><strong>content-box</strong>（默认值）——标准盒模型。元素CSS设置的宽度只是元素实际内容的宽度，不包括padding/border/margin；</p>
<p><strong>border-box</strong>——当文档处于怪异模式时IE使用的盒模型。元素CSS设置的宽度包含实际内容宽度+padding+border</p>
<h3 id="7-inline-block和inline-block的区别"><a href="#7-inline-block和inline-block的区别" class="headerlink" title="7.inline,block和inline-block的区别"></a>7.inline,block和inline-block的区别</h3><blockquote>
<p>inline</p>
</blockquote>
<p>-不独占一行，相邻元素排在一行，直到排不下换行，行尾元素拆成两部分<br>-不可设置宽高<br>-margin、padding只在水平方向有效</p>
<blockquote>
<p>block</p>
</blockquote>
<p>-独占一行，宽度默认填满父元素宽度<br>-可设置宽高<br>-margin、padding有效</p>
<blockquote>
<p>inline-block</p>
</blockquote>
<p>-不独占一行，相邻元素排在一行，直到排不下换行，行尾元素整体移到第二行<br>-可设置宽高<br>-margin、padding有效</p>
<h3 id="8-定位static-relative-absolute-fixed的区别"><a href="#8-定位static-relative-absolute-fixed的区别" class="headerlink" title="8.定位static/relative/absolute/fixed的区别"></a>8.定位static/relative/absolute/fixed的区别</h3><p>一个定位的元素是指它的position的值是relative/absolute/fixed。而top/left/bottom/left属性是针对定位属性的。</p>
<blockquote>
<p> static静态定位</p>
</blockquote>
<p>默认的取值，元素表现为正常行为，布局在文档流的当前位置；<br>top/left/bottom/left/z-index均无效</p>
<blockquote>
<p>relative相对定位</p>
</blockquote>
<p>如果只是设置relative就好像没有定位一样，通过设置top/left/bottom/left使元素针对<strong>自身原本位置</strong>进行偏移；z-index设置层叠等级；<br>相对定位的元素不会影响任何它周围的static元素，例如把relative元素向下50px，那么它可能覆盖下方的static元素；<br>当对象定位到浏览器以外，浏览器显示滚动条</p>
<blockquote>
<p>absolute绝对定位</p>
</blockquote>
<p>元素从文档流中脱离，（正常文档流中好像不存在这个元素一样）会根据<strong>其最接近的已定位祖先元素</strong>来进行定位。设置top/left/bottom/left/z-index；<br>当对象定位到浏览器以外，浏览器显示滚动条</p>
<blockquote>
<p>fixed固定定位</p>
</blockquote>
<p>固定元素独立于页面上的任何元素，总是针对<strong>body元素</strong>进行绝对定位；当滚动条滚动时，元素一直在屏幕上的固定位置；<br>当对象定位到浏览器以外，浏览器不会显示滚动条</p>
<h3 id="9-flex布局"><a href="#9-flex布局" class="headerlink" title="9.flex布局"></a>9.flex布局</h3><p>使用弹性盒子的意义是在任何尺寸的屏幕上改变其和其子元素的尺寸填充可用空间。弹性空间包括主轴和侧轴。<br>设置display:flex或display:inline-flex使一个元素成为flex container，此时它的子元素自动成为flex item，并且子元素的float/clear/vertical-align都会失效。</p>
<h4 id="（1）弹性容器属性"><a href="#（1）弹性容器属性" class="headerlink" title="（1）弹性容器属性"></a>（1）弹性容器属性</h4><blockquote>
<p>flex-direction: 决定主轴的方向</p>
</blockquote>
<p>row | row-reverse | column | column-reverse</p>
<blockquote>
<p>flex-wrap: 项目默认排在一条主轴线上，当一条轴线摆不下时是否换行</p>
</blockquote>
<p>nowrap | wrap | wrap-reverse（不换行 | 换行 | 换行且第一行在下方）</p>
<blockquote>
<p>flex-flow: 是flex-direction和flex-wrap的简写</p>
</blockquote>
<p>默认值 row nowrap</p>
<blockquote>
<p>justify-content：决定项目在主轴的对齐方式</p>
</blockquote>
<p>flex-start | flex-end | center | space-between | space-around（最后一个是指item两边的间隔相等，所以item之间距离是item与边框之间距离的2倍）</p>
<blockquote>
<p>align-items：决定项目在侧轴上的对齐方式</p>
</blockquote>
<p>flex-start | flex-end | center | baseline | stretch（baseline是指项目第一行文字的基线对齐，stretch是指当项目高度未指定时占满容器高度）</p>
<blockquote>
<p>align-content：定义多根轴线的对齐方式</p>
</blockquote>
<p>flex-start | flex-end | center | space-between | space-around | stretch（stretch是指轴线占满整个侧轴）</p>
<h4 id="（2）弹性项目属性"><a href="#（2）弹性项目属性" class="headerlink" title="（2）弹性项目属性"></a>（2）弹性项目属性</h4><blockquote>
<p>order：定义item的排列顺序，取整数值</p>
</blockquote>
<p>默认是0，数值越大越靠后，可以是负数</p>
<blockquote>
<p>align-self：定义某个item自己在侧轴上的对齐方式</p>
</blockquote>
<p>auto | flex-start | flex-end | center | baseline | stretch，它会覆盖容器align-items</p>
<blockquote>
<p>flex-grow：定义item的放大比例；0</p>
</blockquote>
<p>默认为0，即使有剩余空间也不放大，为2的元素占据的剩余空间是为1的元素的两倍</p>
<blockquote>
<p>flex-shrink：定义item的缩小比例；1</p>
</blockquote>
<p>默认为1，空间不足时该项目缩小，若items的这个属性都为1，当空间不足时，大家按等比例缩小，属性为0的item不缩小</p>
<blockquote>
<p>flex-basis：定义在分配多余空间之前item占据的主轴空间</p>
</blockquote>
<p>默认为auto，即项目本来大小</p>
<blockquote>
<p>flex：是flex-grow flex-shrink flex-basis的缩写</p>
</blockquote>
<p>默认值0 1 auto</p>
<h3 id="10-自适应布局和响应式布局的区别"><a href="#10-自适应布局和响应式布局的区别" class="headerlink" title="10.自适应布局和响应式布局的区别"></a>10.自适应布局和响应式布局的区别</h3><p>都是为了解决页面在不同屏幕设备上的显示问题。</p>
<blockquote>
<p>自适应布局</p>
</blockquote>
<p>目的是在不同大小的设备上显示<strong>同样的网页</strong>，会根据屏幕宽度调整内容大小，但不改变布局</p>
<p>利用CSS的媒体查询、js操作HTML元素来适应移动设备；有可能会针对移动端用户减去内容和功能；可能在服务器上通过判断设备，进行了内容优化，把优化过的网页传给终端；</p>
<p>通常只针对几种断点进行优化(1280px,800px,640px,320px)，断点之间的自动过渡比较少。</p>
<blockquote>
<p>响应式布局</p>
</blockquote>
<p>倾向于<strong>改变元素的外观布局</strong>，不改变内容</p>
<p>利用CSS的媒体查询、流体布局(fluid grid)、可自适应的图片资源等来实现，一般都是通过HTML和CSS实现的</p>
<p>在两个断点之间，页面依然随窗口大小自动缩放，直到到达断点改变样式</p>
]]></content>
      
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css面试问题（一）]]></title>
      <url>/2017/07/26/css-question-1/</url>
      <content type="html"><![CDATA[<h3 id="1-css中类和id的区别"><a href="#1-css中类和id的区别" class="headerlink" title="1.css中类和id的区别"></a>1.css中类和id的区别</h3><blockquote>
<p>id</p>
</blockquote>
<p>id是唯一的，每个html元素只能有一个id，同一个id值在一个页面中只能出现一次；权重100；id还可以配合URL中的hash作为锚点使用，便于定位。</p>
<blockquote>
<p>class</p>
</blockquote>
<p>class不唯一，每个html元素可以有多个类，多个元素可以拥有相同的类；权重10。<br><a id="more"></a></p>
<h3 id="2-resetting-css和normalizing-css的区别"><a href="#2-resetting-css和normalizing-css的区别" class="headerlink" title="2.resetting css和normalizing css的区别"></a>2.resetting css和normalizing css的区别</h3><blockquote>
<p>reset</p>
</blockquote>
<p>reset目的是移除所有内置的浏览器样式</p>
<blockquote>
<p>normalize</p>
</blockquote>
<p>normalize目的是使元素样式跨浏览器一致。<br>-保留有用的默认值，而不是覆盖一切样式；<br>-纠正了一些超出reset.css范围的常见错误；<br>-不会扰乱开发者工具，reset使工具中显示大量的继承链；<br>-有更完整的文档</p>
<h3 id="3-浮动的工作原理"><a href="#3-浮动的工作原理" class="headerlink" title="3.浮动的工作原理"></a>3.浮动的工作原理</h3><p>浮动一开始出现的意义是实现文字环绕图片效果。<br>使一个元素脱离正常的文档流，被安放在容器的左端或右端，其他文本或行内元素可以环绕它。float会把元素块级化。<br>取值： left | right | none | inherit<br>带来的副作用是使得父元素高度变为0<br><strong>注意：</strong> js中修改float值用 ele.style.cssFloat || ele.style.styleFloat(IE8-)</p>
<h3 id="4-清除浮动的方法"><a href="#4-清除浮动的方法" class="headerlink" title="4.清除浮动的方法"></a>4.清除浮动的方法</h3><blockquote>
<p>利用clear属性</p>
</blockquote>
<p>1.浮动元素后面紧跟带clear属性的空元素，会将浮动元素重新引入文档流；<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">”clear:both”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>2.不添加空元素，直接在浮动元素后面的有内容元素上添加clear:both样式；<br>3.给父元素添加某个类(常命名为clearfix)<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">    <span class="attribute">display</span>:block;</div><div class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">clear</span>:both;</div><div class="line">    <span class="attribute">visibility</span>:hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>触发父元素形成BFC</p>
</blockquote>
<p>1.浮动元素的父级元素添加 {overflow: auto | hidden | scroll} IE下父元素还要添加zoom:1（zoom触发父元素haslayout）<br>2.父元素设置浮动</p>
<h3 id="5-描述z-index以及层叠上下文的形成"><a href="#5-描述z-index以及层叠上下文的形成" class="headerlink" title="5.描述z-index以及层叠上下文的形成"></a>5.描述z-index以及层叠上下文的形成</h3><blockquote>
<p>z-index</p>
</blockquote>
<p>z-index 属性指定了一个元素及其子元素的 z-order。 当元素之间重叠的时候，z-order 决定哪一个元素覆盖在其余元素的上方显示。 通常来说 z-index 较大的元素会覆盖较小的一个。<br>z-index:auto元素不会创建一个新的本地层叠上下文；z-index:integer是指生成的元素在当前层叠上下文中的堆叠层级，同时创建一个堆叠层级为0的本地堆叠上下文。</p>
<blockquote>
<p>层叠上下文</p>
</blockquote>
<p>层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。<br>层叠上下文的形成：z-index 值不为 “auto”的 绝对/相对定位；opacity属性值小于 1 的元素等。<br><strong>注意：</strong> 子元素的z-index值只在父级层叠上下文中有意义。AB同级，A的z-index是1，B是2，A的子元素a的z-index是5，那么B仍在a的上层。</p>
<h3 id="6-BFC块级格式上下文"><a href="#6-BFC块级格式上下文" class="headerlink" title="6.BFC块级格式上下文"></a>6.BFC块级格式上下文</h3><p>Block Formatting Context是web页面可视化渲染的一部分，提供了一个独立布局的环境，每个BFC都遵循一套相同的布局规则。<br>创建方式：<br>-根元素<br>-绝对定位或固定定位<br>-浮动<br>-display值为inline-block或table-cell或table-caption或flex的元素<br>-块元素<br>-overflow</p>
<h3 id="7-解释CSS-Sprites"><a href="#7-解释CSS-Sprites" class="headerlink" title="7.解释CSS Sprites"></a>7.解释CSS Sprites</h3><blockquote>
<p>原理</p>
</blockquote>
<p>将网页中一些背景图片合并到一张大的图片，利用background-image、background-repeat、background-position、手机端background-size来定位到要显示的背景图片；</p>
<blockquote>
<p>优点</p>
</blockquote>
<p>-减少http请求，提高性能；<br>-减少图片总的字节数；<br>-解决命名困扰；<br>-更换风格方便</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>-合并图片<br>-如果某张背景图片发生变化，整张图可能要重做，维护性差</p>
<h3 id="8-渐进增强和优雅降级"><a href="#8-渐进增强和优雅降级" class="headerlink" title="8.渐进增强和优雅降级"></a>8.渐进增强和优雅降级</h3><blockquote>
<p>渐进增强 progressive enhancement</p>
</blockquote>
<p>先针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<blockquote>
<p>优雅降级 graceful degradation</p>
</blockquote>
<p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<blockquote>
<p>区别</p>
</blockquote>
<p>a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给<br>b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要<br>c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>
<h3 id="9-隐藏元素的方式"><a href="#9-隐藏元素的方式" class="headerlink" title="9.隐藏元素的方式"></a>9.隐藏元素的方式</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display: none; //元素彻底从文档流中消失，不会保留其物理空间</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">visibility: hidden; //元素只是视觉上不可见，仍为其保留物理空间</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">width</span>: 0; <span class="selector-tag">height</span>: 0;</div></pre></td></tr></table></figure>
<h3 id="10-媒体查询"><a href="#10-媒体查询" class="headerlink" title="10.媒体查询"></a>10.媒体查询</h3><p>媒体查询由一个可选的<strong>媒体类型</strong>和零个或多个利用媒体功能<strong>限制样式表范围的表达式</strong>组成。</p>
<blockquote>
<p>媒体类型</p>
</blockquote>
<p>all | screen | print | handheld | tv<br>使用not或only时必须指明媒体类型，否则是可选的，默认是all</p>
<blockquote>
<p>逻辑操作符</p>
</blockquote>
<ul>
<li><p>and把多个媒体属性组合成一条媒体查询，每个属性都为真时，结果才为真</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@media tv and (max-width: 400px) and (orientation: landscape)&#123;.test&#123;//...&#125;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>逗号相当于or，只要有一个属性为真，结果就为真</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@media (max-width: 700px), handheld and (orientation: landscape)&#123;.test&#123;//..&#125;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>not 对一条媒体查询的语句取反</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> not screen and (color), print and (color)</div></pre></td></tr></table></figure>
</li>
<li><p>only 仅在媒体查询成功的情况下应用指定样式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"@media only screen and (max-width:70px)"</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[html 面试问题]]></title>
      <url>/2017/07/24/html-question/</url>
      <content type="html"><![CDATA[<h3 id="1-doctype的作用"><a href="#1-doctype的作用" class="headerlink" title="1.doctype的作用"></a>1.doctype的作用</h3><p>文档类型声明，声明文档是用哪个版本的html编写的，告诉浏览器用哪种规则集来解析文档中的标记。<br><a id="more"></a></p>
<h3 id="2-标准模式、混杂模式、准标准模式的区别"><a href="#2-标准模式、混杂模式、准标准模式的区别" class="headerlink" title="2.标准模式、混杂模式、准标准模式的区别"></a>2.标准模式、混杂模式、准标准模式的区别</h3><blockquote>
<p>区别</p>
</blockquote>
<p><strong>标准模式：</strong> 浏览器几乎遵循最新标准来呈现网页</p>
<p><strong>混杂模式：</strong> 页面以一种宽松的向后兼容的方式呈现</p>
<p><strong>准标准模式：</strong> 几乎要符合标准模式，仍包含一部分混杂模式中的行为</p>
<blockquote>
<p>触发方式</p>
</blockquote>
<p>XHTML包含完整形式的DOCTYPE、HTML4.01包含DTD的DOCTYPE、HTML5包含&lt;!DOCTYPE html>都是标准模式；没有DOCTYPE导致混杂模式。</p>
<blockquote>
<p>具体区别</p>
</blockquote>
<p>针对盒模型中的宽度，标准模式下呈现出content-box的效果，设置的宽度不包括padding和border；混杂模式下呈现出border-box的效果，即设置的宽度已经包含了padding和border。</p>
<blockquote>
<p>模式的检测</p>
</blockquote>
<p>document.compatMode (标准模式值为CSS1Compat; 混杂模式值为BackCompat)</p>
<blockquote>
<p>X-UA-Compatible</p>
</blockquote>
<p>在HTML页面可以指定较低版本的浏览器模式来渲染页面<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=7"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="3-HTML和XHTML的区别"><a href="#3-HTML和XHTML的区别" class="headerlink" title="3.HTML和XHTML的区别"></a>3.HTML和XHTML的区别</h3><p><strong>HTML</strong> 超文本标记语言，它是基于SGML编写的</p>
<p><strong>XHTML</strong> 可扩展文本标记语言，它是基于XML编写的，比前者更严格，XML是SGML的子集。</p>
<p>在XHTML中DOCTYPE强制，html/head/body/title强制，元素必须被正确嵌套、标签关闭、标签小写，属性小写、值有引号等。</p>
<h3 id="4-data-属性的优点"><a href="#4-data-属性的优点" class="headerlink" title="4.data- 属性的优点"></a>4.data- 属性的优点</h3><p>data-是HTML5新定义的属性，用于<strong>存储页面上的私有自定义数据</strong> ，每个元素上都可以定义data-属性。优点是这些存储的数据可以被JavaScript使用，免于ajax获取，优化用户体验。</p>
<p>获取的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ele.getAttribute(<span class="string">'data-num'</span>) <span class="comment">//方式一</span></div><div class="line">ele.dataset.num              <span class="comment">//方式二</span></div></pre></td></tr></table></figure></p>
<h3 id="5-HTML5有哪些特性"><a href="#5-HTML5有哪些特性" class="headerlink" title="5.HTML5有哪些特性"></a>5.HTML5有哪些特性</h3><ul>
<li>更多的语义化标签：header/footer/nav/section/article</li>
<li>更多的表单元素：calendar/email/date/time/url/search</li>
<li>canvas元素和svg</li>
<li>媒体元素audio和vedio</li>
<li>本地离线存储localStorage和sessionStorage</li>
<li>地理定位API</li>
<li>通信API</li>
<li>web worker API</li>
</ul>
<h3 id="6-cookie-sessionStorage-localStorage的区别"><a href="#6-cookie-sessionStorage-localStorage的区别" class="headerlink" title="6.cookie,sessionStorage,localStorage的区别"></a>6.cookie,sessionStorage,localStorage的区别</h3><p>首先这三种都是客户端的存储方案，后两者成为webStorage，是HTML5中新增的特性。以前的本地数据存储是通过cookie实现的，cookie数据会在同源的每个http请求中携带，所以不适合存储大量数据。</p>
<blockquote>
<p>大小</p>
</blockquote>
<p>cookie控制在4kb，webStorage建议每个网站5MB</p>
<blockquote>
<p>方法</p>
</blockquote>
<p>cookie没有封装好的操作方法，只能通过document.cookie来操作；webStorage有封装好的API：getItem/setItem/removeItem/clear<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sessionStorage.setItem(<span class="string">'count'</span>, <span class="string">'123'</span>)</div><div class="line"><span class="keyword">let</span> count = sessionStorage.getItem(<span class="string">'count'</span>)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>请求</p>
</blockquote>
<p>cookie每次请求都携带，webStorage不会自动发给服务器，只存在本地</p>
<blockquote>
<p>生命周期</p>
</blockquote>
<p>cookie可以设置一个过期时间，在过期时间之前一直有效；sessionStorage在窗口关闭前有效，它是针对会话的存储；localStorage一直有效。</p>
<blockquote>
<p>作用域</p>
</blockquote>
<p>cookie作用于所有同源窗口；sessionStorage只作用于当前窗口；localStorage作用于所有同源页面</p>
<h3 id="7-lt-script-gt-lt-script-async-gt-lt-script-defer-gt-的区别"><a href="#7-lt-script-gt-lt-script-async-gt-lt-script-defer-gt-的区别" class="headerlink" title="7.&lt; script &gt;, &lt; script async &gt;, &lt; script defer &gt;的区别"></a>7.&lt; script &gt;, &lt; script async &gt;, &lt; script defer &gt;的区别</h3><blockquote>
<p>script</p>
</blockquote>
<p>浏览器会根据 &lt; script &gt;在页面中出现的顺序依次进行解析，阻塞后面网页的呈现。</p>
<blockquote>
<p>script async</p>
</blockquote>
<p>表示立即下载脚本，下载完就解析执行，不会影响其他操作的执行，比如其他资源的下载。不能确定多个异步加载的脚本文件的执行顺序。通常用于不改变页面结构的CDN文件等。</p>
<blockquote>
<p>script defer</p>
</blockquote>
<p>表示立即下载脚本，但延迟到文档完全被解析和页面显示之后(onload之前)再执行。HTML5要求多个延迟加载的脚本文件按顺序执行，但是现实中不一定，所以最好只包含一个延迟脚本。</p>
<h3 id="8-为什么把css的link放在头部，把js的script放在body之前"><a href="#8-为什么把css的link放在头部，把js的script放在body之前" class="headerlink" title="8.为什么把css的link放在头部，把js的script放在body之前"></a>8.为什么把css的link放在头部，把js的script放在body之前</h3><p>浏览器解析一个文档是按照 <strong>从上到下单线程</strong> 的方式解析的，浏览器加载一个网站时的步骤：1.拿到HTML网页；2.开始解析HTML；3.解析器遇到link标签，会并行下载资源，不会停止对当前文档的处理； 4.解析器遇到script标签，浏览器请求脚本文件，此时会停止解析页面上的其他HTML；5. 下载解析执行完脚本文件，解析器继续解析剩下的HTML文档。</p>
<p>把link放头部，先加载解析样式文件，之后解析并呈现body中元素的时候可以避免页面混乱；把script放底部，这样脚本文件就不会阻塞页面内容的呈现，而且如果脚本中有操作dom结构也不会出现错误。</p>
<h3 id="9-浏览器内核"><a href="#9-浏览器内核" class="headerlink" title="9.浏览器内核"></a>9.浏览器内核</h3><p>浏览器内核又叫浏览器渲染引擎，负责解释网页语法并渲染页面。</p>
<ul>
<li>IE: Trident</li>
<li>Firefox: Gecko</li>
<li>Chrome: Webkit Blink</li>
<li>Safari: webkit</li>
<li>Opera: Blink</li>
</ul>
<h3 id="10-rem和em"><a href="#10-rem和em" class="headerlink" title="10.rem和em"></a>10.rem和em</h3><blockquote>
<p>rem</p>
</blockquote>
<p>rem是指以HTML页面的根元素html的字体大小为基准，设置其他元素的字体大小。具体大小是根元素字体大小*rem值</p>
<blockquote>
<p>em</p>
</blockquote>
<p>当使用em单位时，以父元素的字体大小为基准。具体大小是父元素字体大小*em值</p>
]]></content>
      
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo 基本命令]]></title>
      <url>/2017/07/24/hexo-command/</url>
      <content type="html"><![CDATA[<ul>
<li>Hexo官网—— <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a></li>
<li>Hexo官方文档—— <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a></li>
<li>常见问题—— <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a></li>
<li>提问列表—— <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a></li>
</ul>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="1-创建新文章"><a href="#1-创建新文章" class="headerlink" title="1.创建新文章"></a>1.创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="2-运行服务器"><a href="#2-运行服务器" class="headerlink" title="2.运行服务器"></a>2.运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="3-生成静态文件"><a href="#3-生成静态文件" class="headerlink" title="3.生成静态文件"></a>3.生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="4-部署到网站"><a href="#4-部署到网站" class="headerlink" title="4.部署到网站"></a>4.部署到网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> 命令清单 </category>
            
            <category> hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 命令清单 </tag>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git 基本命令]]></title>
      <url>/2017/07/24/git-command/</url>
      <content type="html"><![CDATA[<h5 id="克隆github上的项目到本地"><a href="#克隆github上的项目到本地" class="headerlink" title="克隆github上的项目到本地"></a>克隆github上的项目到本地</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/cherry0310/xxx.git</div></pre></td></tr></table></figure>
<h5 id="新建develop分支"><a href="#新建develop分支" class="headerlink" title="新建develop分支"></a>新建develop分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b develop</div></pre></td></tr></table></figure>
<h5 id="删除develop分支"><a href="#删除develop分支" class="headerlink" title="删除develop分支"></a>删除develop分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d develop</div></pre></td></tr></table></figure>
<h5 id="切换到develop分支"><a href="#切换到develop分支" class="headerlink" title="切换到develop分支"></a>切换到develop分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout develop</div></pre></td></tr></table></figure>
<h5 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch</div></pre></td></tr></table></figure>
<h5 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -a</div></pre></td></tr></table></figure>
<h5 id="添加修改"><a href="#添加修改" class="headerlink" title="添加修改"></a>添加修改</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git add -A</div></pre></td></tr></table></figure>
<h5 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m <span class="string">'修改原因'</span></div></pre></td></tr></table></figure>
<h5 id="推送到远程"><a href="#推送到远程" class="headerlink" title="推送到远程"></a>推送到远程</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push</div></pre></td></tr></table></figure>
<h5 id="将本地develop分支关联到远程develop分支"><a href="#将本地develop分支关联到远程develop分支" class="headerlink" title="将本地develop分支关联到远程develop分支"></a>将本地develop分支关联到远程develop分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push --<span class="built_in">set</span>-upstream origin develop</div></pre></td></tr></table></figure>
<h5 id="查看版本之间的差异"><a href="#查看版本之间的差异" class="headerlink" title="查看版本之间的差异"></a>查看版本之间的差异</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff</div></pre></td></tr></table></figure>
<h5 id="将develop分支合并到master"><a href="#将develop分支合并到master" class="headerlink" title="将develop分支合并到master"></a>将develop分支合并到master</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --no-ff develop</div></pre></td></tr></table></figure>
<ul>
<li>不使用–no-ff，git执行快进式合并，master直接指向develop分支</li>
<li>使用–no-ff，git执行正常合并，在master支上生成新节点</li>
</ul>
<h5 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d develop</div></pre></td></tr></table></figure>
<h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin --delete develop</div></pre></td></tr></table></figure>
<h5 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">log</span></div></pre></td></tr></table></figure>
<h5 id="回退到某个版本"><a href="#回退到某个版本" class="headerlink" title="回退到某个版本"></a>回退到某个版本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard f17a150b38d332015ab5911c5820dee385c420db</div></pre></td></tr></table></figure>
<h5 id="回退后强制提交"><a href="#回退后强制提交" class="headerlink" title="回退后强制提交"></a>回退后强制提交</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push -f</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 命令清单 </category>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> 命令清单 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>大家好，我是cherry。欢迎来到我的个人技术博客。</p>
]]></content>
    </entry>
    
  
</search>
